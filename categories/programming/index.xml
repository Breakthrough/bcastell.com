<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on Brandon Castellano</title>
    <link>https://www.bcastell.com/categories/programming/index.xml</link>
    <description>Recent content in Programming on Brandon Castellano</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright &amp;copy; 2017, Brandon Castellano.  All rights reserved.</copyright>
    <atom:link href="https://www.bcastell.com/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Scene Detection with Python and OpenCV, Part 2</title>
      <link>https://www.bcastell.com/posts/scene-detection-tutorial-part-2/</link>
      <pubDate>Wed, 06 Sep 2017 01:14:08 +0200</pubDate>
      
      <guid>https://www.bcastell.com/posts/scene-detection-tutorial-part-2/</guid>
      <description>

&lt;h1 id=&#34;part-2-adaptive-threshold-detection&#34;&gt;Part 2: Adaptive Threshold Detection&lt;/h1&gt;

&lt;p&gt;This tutorial is currently being migrated from the old location.  In the meantime, you can view the cached version of the previous, complete version on The Wayback Machine &lt;a href=&#34;https://web.archive.org/web/20160316124732/http://www.bcastell.com/tech-articles/pyscenedetect-tutorial-part-2/&#34;&gt;by clicking here&lt;/a&gt;.  Thank you for your patience during this time.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linked post</title>
      <link>https://www.bcastell.com/posts/linked-post/</link>
      <pubDate>Fri, 02 Oct 2015 21:49:20 +0200</pubDate>
      
      <guid>https://www.bcastell.com/posts/linked-post/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m a linked post in the menu. You can add other posts by adding the following line to the frontmatter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;menu = &amp;quot;main&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. In mauris nulla, vestibulum vel auctor sed, posuere eu lorem. Aliquam consequat augue ut accumsan mollis. Suspendisse malesuada sodales tincidunt. Vivamus sed erat ac augue bibendum porta sed id ipsum. Ut mollis mauris eget ligula sagittis cursus. Aliquam id pharetra tellus. Pellentesque sed tempus risus. Proin id hendrerit ante. Vestibulum vitae urna ut mauris ultricies dignissim. Ut ante turpis, tristique vitae sagittis quis, sagittis nec diam. Fusce pulvinar cursus porta. Vivamus maximus leo dolor, ut pellentesque lorem fringilla nec. Mauris faucibus turpis posuere sapien euismod, a ullamcorper mi maximus.&lt;/p&gt;

&lt;p&gt;Morbi varius ex vel justo dictum placerat. Sed ac arcu pretium, varius elit eget, gravida purus. Fusce sit amet massa mollis eros tincidunt sollicitudin. Suspendisse iaculis cursus mauris ut sagittis. Interdum et malesuada fames ac ante ipsum primis in faucibus. Maecenas elit ligula, molestie quis magna eu, semper posuere lorem. Mauris a justo pharetra, congue ex eget, tincidunt massa. Maecenas sit amet neque lorem.&lt;/p&gt;

&lt;p&gt;Curabitur at elementum quam. Curabitur tristique elit non sapien aliquam vulputate. Vivamus in odio tincidunt, tempor sem quis, tincidunt lacus. Mauris pulvinar nunc sed tempus dictum. Nam vel arcu quis mi fermentum ullamcorper non ac lacus. Donec aliquet vitae ante at imperdiet. Aenean scelerisque venenatis urna, eget elementum risus convallis ac. Nullam gravida arcu lacus, non consectetur augue pretium non. Duis dignissim eros id urna pretium congue. Nullam eu magna in sem sollicitudin tempor. Pellentesque vel convallis ligula. Quisque semper, turpis a rhoncus efficitur, magna nibh iaculis elit, eget tempor dolor eros ut mi. Maecenas eu placerat lacus. Praesent congue pretium nulla, sed suscipit metus rutrum vel.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go is for lovers</title>
      <link>https://www.bcastell.com/posts/go-is-for-lovers/</link>
      <pubDate>Thu, 17 Sep 2015 13:47:08 +0200</pubDate>
      
      <guid>https://www.bcastell.com/posts/go-is-for-lovers/</guid>
      <description>

&lt;p&gt;Hugo uses the excellent &lt;a href=&#34;http://golang.org/&amp;gt;&#34;&gt;go&lt;/a&gt; &lt;a href=&#34;http://golang.org/pkg/html/template/&amp;gt;&#34;&gt;html/template&lt;/a&gt; library for
its template engine. It is an extremely lightweight engine that provides a very
small amount of logic. In our experience that it is just the right amount of
logic to be able to create a good static website. If you have used other
template systems from different languages or frameworks you will find a lot of
similarities in go templates.&lt;/p&gt;

&lt;p&gt;This document is a brief primer on using go templates. The &lt;a href=&#34;http://golang.org/pkg/html/template/&amp;gt;&#34;&gt;go docs&lt;/a&gt;
provide more details.&lt;/p&gt;

&lt;h2 id=&#34;introduction-to-go-templates&#34;&gt;Introduction to Go Templates&lt;/h2&gt;

&lt;p&gt;Go templates provide an extremely simple template language. It adheres to the
belief that only the most basic of logic belongs in the template or view layer.
One consequence of this simplicity is that go templates parse very quickly.&lt;/p&gt;

&lt;p&gt;A unique characteristic of go templates is they are content aware. Variables and
content will be sanitized depending on the context of where they are used. More
details can be found in the &lt;a href=&#34;http://golang.org/pkg/html/template/&amp;gt;&#34;&gt;go docs&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;basic-syntax&#34;&gt;Basic Syntax&lt;/h2&gt;

&lt;p&gt;Go lang templates are html files with the addition of variables and
functions.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Go variables and functions are accessible within {{ }}&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Accessing a predefined variable &amp;ldquo;foo&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ foo }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Parameters are separated using spaces&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Calling the add function with input of 1, 2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ add 1 2 }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Methods and fields are accessed via dot notation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Accessing the Page Parameter &amp;ldquo;bar&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ .Params.bar }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Parentheses can be used to group items together&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ if or (isset .Params &amp;quot;alt&amp;quot;) (isset .Params &amp;quot;caption&amp;quot;) }} Caption {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;variables&#34;&gt;Variables&lt;/h2&gt;

&lt;p&gt;Each go template has a struct (object) made available to it. In hugo each
template is passed either a page or a node struct depending on which type of
page you are rendering. More details are available on the
&lt;a href=&#34;https://www.bcastell.com/layout/variables&#34;&gt;variables&lt;/a&gt; page.&lt;/p&gt;

&lt;p&gt;A variable is accessed by referencing the variable name.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;title&amp;gt;{{ .Title }}&amp;lt;/title&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Variables can also be defined and referenced.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ $address := &amp;quot;123 Main St.&amp;quot;}}
{{ $address }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;functions&#34;&gt;Functions&lt;/h2&gt;

&lt;p&gt;Go template ship with a few functions which provide basic functionality. The go
template system also provides a mechanism for applications to extend the
available functions with their own. &lt;a href=&#34;https://www.bcastell.com/layout/functions&#34;&gt;Hugo template
functions&lt;/a&gt; provide some additional functionality we believe
are useful for building websites. Functions are called by using their name
followed by the required parameters separated by spaces. Template
functions cannot be added without recompiling hugo.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ add 1 2 }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;includes&#34;&gt;Includes&lt;/h2&gt;

&lt;p&gt;When including another template you will pass to it the data it will be
able to access. To pass along the current context please remember to
include a trailing dot. The templates location will always be starting at
the /layout/ directory within Hugo.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ template &amp;quot;chrome/header.html&amp;quot; . }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;logic&#34;&gt;Logic&lt;/h2&gt;

&lt;p&gt;Go templates provide the most basic iteration and conditional logic.&lt;/p&gt;

&lt;h3 id=&#34;iteration&#34;&gt;Iteration&lt;/h3&gt;

&lt;p&gt;Just like in go, the go templates make heavy use of range to iterate over
a map, array or slice. The following are different examples of how to use
range.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example 1: Using Context&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ range array }}
    {{ . }}
{{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example 2: Declaring value variable name&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{range $element := array}}
    {{ $element }}
{{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example 2: Declaring key and value variable name&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{range $index, $element := array}}
    {{ $index }}
    {{ $element }}
{{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditionals&#34;&gt;Conditionals&lt;/h3&gt;

&lt;p&gt;If, else, with, or, &amp;amp; and provide the framework for handling conditional
logic in Go Templates. Like range, each statement is closed with &lt;code&gt;end&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Go Templates treat the following values as false:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;false&lt;/li&gt;
&lt;li&gt;0&lt;/li&gt;
&lt;li&gt;any array, slice, map, or string of length zero&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Example 1: If&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ if isset .Params &amp;quot;title&amp;quot; }}&amp;lt;h4&amp;gt;{{ index .Params &amp;quot;title&amp;quot; }}&amp;lt;/h4&amp;gt;{{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example 2: If -&amp;gt; Else&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ if isset .Params &amp;quot;alt&amp;quot; }}
    {{ index .Params &amp;quot;alt&amp;quot; }}
{{else}}
    {{ index .Params &amp;quot;caption&amp;quot; }}
{{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example 3: And &amp;amp; Or&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ if and (or (isset .Params &amp;quot;title&amp;quot;) (isset .Params &amp;quot;caption&amp;quot;)) (isset .Params &amp;quot;attr&amp;quot;)}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example 4: With&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;An alternative way of writing &amp;ldquo;if&amp;rdquo; and then referencing the same value
is to use &amp;ldquo;with&amp;rdquo; instead. With rebinds the context &lt;code&gt;.&lt;/code&gt; within its scope,
and skips the block if the variable is absent.&lt;/p&gt;

&lt;p&gt;The first example above could be simplified as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ with .Params.title }}&amp;lt;h4&amp;gt;{{ . }}&amp;lt;/h4&amp;gt;{{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example 5: If -&amp;gt; Else If&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ if isset .Params &amp;quot;alt&amp;quot; }}
    {{ index .Params &amp;quot;alt&amp;quot; }}
{{ else if isset .Params &amp;quot;caption&amp;quot; }}
    {{ index .Params &amp;quot;caption&amp;quot; }}
{{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pipes&#34;&gt;Pipes&lt;/h2&gt;

&lt;p&gt;One of the most powerful components of go templates is the ability to
stack actions one after another. This is done by using pipes. Borrowed
from unix pipes, the concept is simple, each pipeline&amp;rsquo;s output becomes the
input of the following pipe.&lt;/p&gt;

&lt;p&gt;Because of the very simple syntax of go templates, the pipe is essential
to being able to chain together function calls. One limitation of the
pipes is that they only can work with a single value and that value
becomes the last parameter of the next pipeline.&lt;/p&gt;

&lt;p&gt;A few simple examples should help convey how to use the pipe.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example 1 :&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ if eq 1 1 }} Same {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is the same as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ eq 1 1 | if }} Same {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It does look odd to place the if at the end, but it does provide a good
illustration of how to use the pipes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example 2 :&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ index .Params &amp;quot;disqus_url&amp;quot; | html }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Access the page parameter called &amp;ldquo;disqus_url&amp;rdquo; and escape the HTML.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example 3 :&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ if or (or (isset .Params &amp;quot;title&amp;quot;) (isset .Params &amp;quot;caption&amp;quot;)) (isset .Params &amp;quot;attr&amp;quot;)}}
Stuff Here
{{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Could be rewritten as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{  isset .Params &amp;quot;caption&amp;quot; | or isset .Params &amp;quot;title&amp;quot; | or isset .Params &amp;quot;attr&amp;quot; | if }}
Stuff Here
{{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;context-aka-the-dot&#34;&gt;Context (aka. the dot)&lt;/h2&gt;

&lt;p&gt;The most easily overlooked concept to understand about go templates is that {{ . }}
always refers to the current context. In the top level of your template this
will be the data set made available to it. Inside of a iteration it will have
the value of the current item. When inside of a loop the context has changed. .
will no longer refer to the data available to the entire page. If you need to
access this from within the loop you will likely want to set it to a variable
instead of depending on the context.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  {{ $title := .Site.Title }}
  {{ range .Params.tags }}
    &amp;lt;li&amp;gt; &amp;lt;a href=&amp;quot;{{ $baseurl }}/tags/{{ . | urlize | lower  }}&amp;quot;&amp;gt;{{ . }}&amp;lt;/a&amp;gt; - {{ $title }} &amp;lt;/li&amp;gt;
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how once we have entered the loop the value of {{ . }} has changed. We
have defined a variable outside of the loop so we have access to it from within
the loop.&lt;/p&gt;

&lt;h1 id=&#34;hugo-parameters&#34;&gt;Hugo Parameters&lt;/h1&gt;

&lt;p&gt;Hugo provides the option of passing values to the template language
through the site configuration (for sitewide values), or through the meta
data of each specific piece of content. You can define any values of any
type (supported by your front matter/config format) and use them however
you want to inside of your templates.&lt;/p&gt;

&lt;h2 id=&#34;using-content-page-parameters&#34;&gt;Using Content (page) Parameters&lt;/h2&gt;

&lt;p&gt;In each piece of content you can provide variables to be used by the
templates. This happens in the &lt;a href=&#34;https://www.bcastell.com/content/front-matter&#34;&gt;front matter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;An example of this is used in this documentation site. Most of the pages
benefit from having the table of contents provided. Sometimes the TOC just
doesn&amp;rsquo;t make a lot of sense. We&amp;rsquo;ve defined a variable in our front matter
of some pages to turn off the TOC from being displayed.&lt;/p&gt;

&lt;p&gt;Here is the example front matter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title: &amp;quot;Permalinks&amp;quot;
date: &amp;quot;2013-11-18&amp;quot;
aliases:
  - &amp;quot;/doc/permalinks/&amp;quot;
groups: [&amp;quot;extras&amp;quot;]
groups_weight: 30
notoc: true
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the corresponding code inside of the template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  {{ if not .Params.notoc }}
    &amp;lt;div id=&amp;quot;toc&amp;quot; class=&amp;quot;well col-md-4 col-sm-6&amp;quot;&amp;gt;
    {{ .TableOfContents }}
    &amp;lt;/div&amp;gt;
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;using-site-config-parameters&#34;&gt;Using Site (config) Parameters&lt;/h2&gt;

&lt;p&gt;In your top-level configuration file (eg, &lt;code&gt;config.yaml&lt;/code&gt;) you can define site
parameters, which are values which will be available to you in chrome.&lt;/p&gt;

&lt;p&gt;For instance, you might declare:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;params:
  CopyrightHTML: &amp;quot;Copyright &amp;amp;#xA9; 2013 John Doe. All Rights Reserved.&amp;quot;
  TwitterUser: &amp;quot;spf13&amp;quot;
  SidebarRecentLimit: 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Within a footer layout, you might then declare a &lt;code&gt;&amp;lt;footer&amp;gt;&lt;/code&gt; which is only
provided if the &lt;code&gt;CopyrightHTML&lt;/code&gt; parameter is provided, and if it is given,
you would declare it to be HTML-safe, so that the HTML entity is not escaped
again.  This would let you easily update just your top-level config file each
January 1st, instead of hunting through your templates.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{if .Site.Params.CopyrightHTML}}&amp;lt;footer&amp;gt;
&amp;lt;div class=&amp;quot;text-center&amp;quot;&amp;gt;{{.Site.Params.CopyrightHTML | safeHtml}}&amp;lt;/div&amp;gt;
&amp;lt;/footer&amp;gt;{{end}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An alternative way of writing the &amp;ldquo;if&amp;rdquo; and then referencing the same value
is to use &amp;ldquo;with&amp;rdquo; instead. With rebinds the context &lt;code&gt;.&lt;/code&gt; within its scope,
and skips the block if the variable is absent:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{with .Site.Params.TwitterUser}}&amp;lt;span class=&amp;quot;twitter&amp;quot;&amp;gt;
&amp;lt;a href=&amp;quot;https://twitter.com/{{.}}&amp;quot; rel=&amp;quot;author&amp;quot;&amp;gt;
&amp;lt;img src=&amp;quot;/images/twitter.png&amp;quot; width=&amp;quot;48&amp;quot; height=&amp;quot;48&amp;quot; title=&amp;quot;Twitter: {{.}}&amp;quot;
 alt=&amp;quot;Twitter&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;/span&amp;gt;{{end}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, if you want to pull &amp;ldquo;magic constants&amp;rdquo; out of your layouts, you can do
so, such as in this example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;nav class=&amp;quot;recent&amp;quot;&amp;gt;
  &amp;lt;h1&amp;gt;Recent Posts&amp;lt;/h1&amp;gt;
  &amp;lt;ul&amp;gt;{{range first .Site.Params.SidebarRecentLimit .Site.Recent}}
    &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{{.RelPermalink}}&amp;quot;&amp;gt;{{.Title}}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  {{end}}&amp;lt;/ul&amp;gt;
&amp;lt;/nav&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Scene Detection with Python and OpenCV, Part 1</title>
      <link>https://www.bcastell.com/posts/scene-detection-tutorial-part-1/</link>
      <pubDate>Sat, 19 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.bcastell.com/posts/scene-detection-tutorial-part-1/</guid>
      <description>

&lt;h2 id=&#34;part-1-threshold-fade-to-black-detection&#34;&gt;Part 1: Threshold/Fade-to-Black Detection&lt;/h2&gt;

&lt;p&gt;This tutorial is currently being migrated from the old location.  In the meantime, you can view the cached version of the previous, complete version on The Wayback Machine &lt;a href=&#34;https://web.archive.org/web/20160316225649/http://www.bcastell.com/tech-articles/pyscenedetect-tutorial-part-1/&#34;&gt;by clicking here&lt;/a&gt;.  Thank you for your patience during this time.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;In the first part of this three-part tutorial, we will write a Python program, using the OpenCV library, to perform threshold-based scene detection, to determine the exact frames where scene transitions (fade ins/outs to/from black in this case) occur. In the following tutorials, we will optimize our scene detection algorithm, and use the output to create a scene list with proper timecodes (&lt;a href=&#34;https://www.bcastell.com/posts/scene-detection-tutorial-part-2/&#34;&gt;Part 2&lt;/a&gt;) so a video can be split automatically into scenes. Lastly, we will cover how to detect content-based scene changes (in a future Part 3, coming soon), and combine this with the concepts from the previous tutorials to create a robust scene detection program.&lt;/p&gt;

&lt;p&gt;You can download the source code and test video from this tutorial via the Github repository (see the Releases page to download everything in a single zip/tar archive).&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;introduction-installation&#34;&gt;Introduction &amp;amp; Installation&lt;/h3&gt;

&lt;p&gt;The OpenCV bindings for Python allow you to quickly experiment with images/videos. Specifically, the OpenCV library handles all the low-level interfacing to actually decode video data (using FFmpeg, and thus is compatible with many different video formats), and uniquely, the returned video frames – as well as other image objects for that matter – can be accessed as a &lt;a href=&#34;http://numpy.scipy.org/&#34;&gt;NumPy&lt;/a&gt; array. This allows you to perform MATLAB/Octave-like operations on the image data easily and concisely.&lt;/p&gt;

&lt;p&gt;Firstly, this tutorial assumes that you have installed Python 2.7 (I believe at the time of writing this, the OpenCV bindings are only available for 2.7), as well as the OpenCV bindings themselves. If you are a Windows user, you might want to see &lt;a href=&#34;http://stackoverflow.com/questions/4709301/installing-opencv-on-windows-7-for-python-2-7&#34;&gt;this question on Stack Overflow&lt;/a&gt;; on Linux, I was able to install the bindings right from my package manager. To verify that everything is installed correctly, fire up a Python console, and type &lt;code&gt;import cv2&lt;/code&gt;. If there are no errors, everything should be set up correctly!&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;the-problem-at-hand&#34;&gt;The Problem at Hand&lt;/h3&gt;

&lt;p&gt;The goals of this program (PySceneDetect) are to detect when a scene change in a video occurs. In this particular tutorial, we will focus on fades in from, or out to black. The following figure depicts the type of scene changes we will be detecting:&lt;/p&gt;

&lt;div style=&#34;background:#334455;padding:0.75em;margin:1em 4em;&#34;&gt;&lt;center&gt;
&lt;img src=&#34;https://www.bcastell.com/img/tutorials/scenedetect/fadetypes.png&#34; alt=&#34;Types of Scene Changes&#34;/&gt;
&lt;/center&gt;&lt;/div&gt;

&lt;p&gt;The output of PySceneDetect will be a text-file containing the timestamps of each event (either a fade-from or fade-to black). The idea is that these timecodes can then be used to split the source video into individual scenes with another program (mkvmerge, VideoDub, etc…). In this part of the tutorial, we will print the time and frame number for each fade event to the console.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;decoding-video-frames&#34;&gt;Decoding Video Frames&lt;/h3&gt;

&lt;p&gt;Let’s begin by creating a &lt;a href=&#34;http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#videocapture&#34;&gt;VideoCapture object&lt;/a&gt;, which can be used to open either a camera stream or a video file, and retrieve individual frames. Let’s assume the name of the video is passed as the first argument to the script, and do some simple error checking and cleanup just to be safe:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;sys&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;cv2&lt;/span&gt;
 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;():
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;len&lt;/span&gt;(sys&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;argv) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;:
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Error - file name must be specified as first argument.&amp;quot;&lt;/span&gt;
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt;
 
    cap &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; cv2&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;VideoCapture()
    cap&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;open(sys&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;argv[&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;])
 
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;not&lt;/span&gt; cap&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;isOpened():
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Fatal error - could not open video &lt;/span&gt;&lt;span style=&#34;color: #BB6688; font-weight: bold&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;.&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; sys&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;argv[&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;]
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt;:
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Parsing video &lt;/span&gt;&lt;span style=&#34;color: #BB6688; font-weight: bold&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;...&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; sys&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;argv[&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;]
 
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# Do stuff with cap here.&lt;/span&gt;
 
    cap&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;release()
 
 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color: #19177C&#34;&gt;__name__&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;:
    main()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Once we have a valid VideoCapture object (i.e. the isOpened() method returns true), we can use &lt;a href=&#34;http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#videocapture-read&#34;&gt;the &lt;code&gt;read()&lt;/code&gt; method&lt;/a&gt; to start grabbing frames. Note that read() returns a tuple in the form (retval, image), and when retval is returned as false, this denotes that there are no more frames in the object to grab (and thus we are at the end of the video). Let’s make a loop to scan through the video and retrieve each frame, as well as print some basic information about the video):&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;width  &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; cap&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;get(cv2&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;cv&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;CV_CAP_PROP_FRAME_WIDTH)
height &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; cap&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;get(cv2&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;cv&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;CV_CAP_PROP_FRAME_HEIGHT)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Video Resolution: &lt;/span&gt;&lt;span style=&#34;color: #BB6688; font-weight: bold&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt; x &lt;/span&gt;&lt;span style=&#34;color: #BB6688; font-weight: bold&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; (width, height)
 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;True&lt;/span&gt;:
    (rv, im) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; cap&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;read()   &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# im is a valid image if and only if rv is true&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;not&lt;/span&gt; rv:
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;break&lt;/span&gt;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# Do stuff with im here.&lt;/span&gt;
 
frame_count &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; cap&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;get(cv2&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;cv&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;CV_CAP_PROP_POS_FRAMES)  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# current capture position&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Read &lt;/span&gt;&lt;span style=&#34;color: #BB6688; font-weight: bold&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt; frames from video.&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; frame_count
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note that the returned image &lt;code&gt;im&lt;/code&gt; is a Mat type object, and can be accessed with the same methods as a NumPy array due to the compatibility in it’s implementation.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;working-with-images-detecting-scene-changes&#34;&gt;Working With Images &amp;amp; Detecting Scene Changes&lt;/h3&gt;

&lt;p&gt;Now that we have the image, we need to analyze it to determine when a scene cut occurs. Since we want to know when we have faded in or out of black, we can compute the average intensity of the pixels in the image, and compare this with a set threshold denoting the black level. We need to compare the average to a threshold and not simply zero, since compression artifacts or encoders sometimes will not produce a fully black frame.&lt;/p&gt;

&lt;p&gt;Since we have the ability to access &lt;code&gt;im&lt;/code&gt; as if it were a NumPy array, we can use &lt;a href=&#34;http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.mean.html#numpy.ndarray.mean&#34;&gt;the &lt;code&gt;mean()&lt;/code&gt; ndarray method&lt;/a&gt; on &lt;code&gt;im&lt;/code&gt; to compute the average intensity of the pixels in the frame. We can compare this value to our set threshold, as well as the average intensity of the past frame (to determine if we are fading in to or out from a scene) to determine where the scene cuts occur by modifying the above while-loop as follows:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# Allow the threshold to be passed as an optional second argument to the script.&lt;/span&gt;
threshold &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;15&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;len&lt;/span&gt;(sys&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;argv) &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;and&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;int&lt;/span&gt;(sys&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;argv[&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;]) &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;:
    threshold &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;int&lt;/span&gt;(sys&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;argv[&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;])
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Detecting scenes with threshold &lt;/span&gt;&lt;span style=&#34;color: #BB6688; font-weight: bold&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;.&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; threshold
 
last_mean &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;       &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# Mean pixel intensity of the *last* frame we processed.&lt;/span&gt;
 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;True&lt;/span&gt;:
    (rv, im) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; cap&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;read()   &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# im is a valid image if and only if rv is true&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;not&lt;/span&gt; rv:
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;break&lt;/span&gt;
    frame_mean &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; im&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;mean()
 
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# Detect fade in from black.&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; frame_mean &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;=&lt;/span&gt; threshold &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;and&lt;/span&gt; last_mean &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; threshold:
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Detected fade in at &lt;/span&gt;&lt;span style=&#34;color: #BB6688; font-weight: bold&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;ms (frame &lt;/span&gt;&lt;span style=&#34;color: #BB6688; font-weight: bold&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;).&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; (
            cap&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;get(cv2&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;cv&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;CV_CAP_PROP_POS_MSEC),
            cap&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;get(cv2&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;cv&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;CV_CAP_PROP_POS_FRAMES) )
 
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# Detect fade out to black.&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;elif&lt;/span&gt; frame_mean &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; threshold &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;and&lt;/span&gt; last_mean &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;=&lt;/span&gt; threshold:
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Detected fade out at &lt;/span&gt;&lt;span style=&#34;color: #BB6688; font-weight: bold&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;ms (frame &lt;/span&gt;&lt;span style=&#34;color: #BB6688; font-weight: bold&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;).&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; (
            cap&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;get(cv2&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;cv&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;CV_CAP_PROP_POS_MSEC),
            cap&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;get(cv2&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;cv&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;CV_CAP_PROP_POS_FRAMES) )
 
    last_mean &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; frame_mean     &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# Store current mean to compare in next iteration.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And it’s that easy – you now know when a scene is fading in or out from your videos, based on the defined threshold! While the timecode is presented in milliseconds, a frame number is also shown, which should help if you just want to manually find scene changes in a video. In practice, I found the &lt;code&gt;mean()&lt;/code&gt; methods provided by OpenCV and NumPy to be fairly slower than computing the average from the sum and image size:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# Compute mean intensity of pixels in frame.&lt;/span&gt;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# Previously: frame_mean = im.mean()&lt;/span&gt;
    frame_mean &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;sum(im) &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;float&lt;/span&gt;(im&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;shape[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; im&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;shape[&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; im&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;shape[&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;])
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# Dividing the sum by the image size is 35-40% faster than using&lt;/span&gt;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# either im.mean() or np.mean(im).&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This change brings the runtime down from 4.10 seconds to 2.86 seconds (for parsing the entire &lt;code&gt;testvideo.mp4&lt;/code&gt; file), with a resulting increase in processing speed from 176 FPS to 251 FPS.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;testing-conclusion&#34;&gt;Testing &amp;amp; Conclusion&lt;/h3&gt;

&lt;p&gt;You can download the source code and test video from this tutorial via &lt;a href=&#34;https://github.com/Breakthrough/python-scene-detection-tutorial&#34;&gt;the Github repository&lt;/a&gt; (see &lt;a href=&#34;https://github.com/Breakthrough/python-scene-detection-tutorial/releases/&#34;&gt;the Releases page&lt;/a&gt; to download everything in a single zip/tar archive). The code from this part is in &lt;a href=&#34;https://github.com/Breakthrough/python-scene-detection-tutorial/blob/master/examples/part1-threshold.py&#34;&gt;the file &lt;code&gt;part1-threshold.py&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Invoking the Python program for this part using the included &lt;code&gt;testvideo.mp4&lt;/code&gt; file, you should obtain this output:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&amp;gt; python ./part1-threshold.py testvideo.mp4
Parsing video testvideo.mp4...
Video Resolution: 1280 x 720
Detecting scenes with threshold = 15.
 
Detected fade in at 1167ms (frame 35).
Detected fade out at 6172ms (frame 185).
Detected fade in at 7440ms (frame 223).
Detected fade out at 11945ms (frame 358).
Detected fade in at 13480ms (frame 404).
Detected fade out at 23156ms (frame 694).
Read 719 frames from video in 2.86 seconds (avg. 251.1 FPS).
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If we change the threshold from 15 to 50, we see that it has the expected result for each type of cut. Hard cuts are unaffected, and the fade in/out times are shifted forwards/backwards in time, respectively:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&amp;gt; python ./part1-threshold.py testvideo.mp4 50
Parsing video testvideo.mp4...
Video Resolution: 1280 x 720
Detecting scenes with threshold = 50.
 
Detected fade in at 1167ms (frame 35).
Detected fade out at 6172ms (frame 185).
Detected fade in at 7974ms (frame 239).
Detected fade out at 11411ms (frame 342).
Detected fade in at 13913ms (frame 417).
Detected fade out at 22722ms (frame 681).
Read 719 frames from video in 2.96 seconds (avg. 242.9 FPS).
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Just as expected! And that’s all for the first part. You can use the program for this part as-is, for a quick method to determine the frame numbers where transitions to/from black occur in a video; see the header of the &lt;code&gt;part1-threshold.py&lt;/code&gt; file for usage details.&lt;/p&gt;

&lt;p&gt;The next tutorial in the series is &lt;a href=&#34;https://www.bcastell.com/posts/scene-detection-tutorial-part-2/&#34;&gt;Part 2: Adaptive Threshold Detection&lt;/a&gt;, where we optimize the performance of the algorithm, and use the output to export a list of scenes/chapters (instead of fades).&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Post last updated September 15, 2014, and moved to new location on September 8, 2017.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>