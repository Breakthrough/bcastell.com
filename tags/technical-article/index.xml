<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>technical article on Brandon Castellano</title>
    <link>https://www.bcastell.com/tags/technical-article/</link>
    <description>Recent content in technical article on Brandon Castellano</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 06 Sep 2017 01:14:08 +0200</lastBuildDate>
    
	<atom:link href="https://www.bcastell.com/tags/technical-article/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Scene Detection with Python and OpenCV, Part 2</title>
      <link>https://www.bcastell.com/posts/scene-detection-tutorial-part-2/</link>
      <pubDate>Wed, 06 Sep 2017 01:14:08 +0200</pubDate>
      
      <guid>https://www.bcastell.com/posts/scene-detection-tutorial-part-2/</guid>
      <description>Part 2: Adaptive Threshold Detection This tutorial is currently being migrated from the old location. In the meantime, you can view the cached version of the previous, complete version on The Wayback Machine by clicking here. Thank you for your patience during this time.</description>
    </item>
    
    <item>
      <title>Scene Detection with Python and OpenCV, Part 1</title>
      <link>https://www.bcastell.com/posts/scene-detection-tutorial-part-1/</link>
      <pubDate>Sat, 19 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.bcastell.com/posts/scene-detection-tutorial-part-1/</guid>
      <description>Part 1: Threshold/Fade-to-Black Detection This tutorial is currently being migrated from the old location. In the meantime, you can view the cached version of the previous, complete version on The Wayback Machine by clicking here. Thank you for your patience during this time.
In the first part of this three-part tutorial, we will write a Python program, using the OpenCV library, to perform threshold-based scene detection, to determine the exact frames where scene transitions (fade ins/outs to/from black in this case) occur.</description>
    </item>
    
    <item>
      <title>How does word length affect the performance and operation of a CPU?</title>
      <link>https://www.bcastell.com/posts/word-length-vs-performance/</link>
      <pubDate>Wed, 17 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>https://www.bcastell.com/posts/word-length-vs-performance/</guid>
      <description>About a year ago, I came across a question on Super User titled “How much faster is a 64-bit CPU than a 32-bit CPU?”, which was promptly closed and deleted since it’s a very open ended question. However, the author (a software developer) referred to benchmarks regarding system performance in 32-bit versus 64-bit. The purpose of this blog post is to investigate how the performance of a computer is affected, as a function of the word length.</description>
    </item>
    
    <item>
      <title>Fixing the XAnalogTV Screensaver</title>
      <link>https://www.bcastell.com/posts/fixing-xanalogtv/</link>
      <pubDate>Mon, 10 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>https://www.bcastell.com/posts/fixing-xanalogtv/</guid>
      <description>A few days ago, I discovered the awesome XAnalogTV screensaver included with XScreenSaver. I was very impressed with the visuals, which include a very accurate simulation of a conventional “tube” television implementing the analog NTSC TV standard. There was just one problem – I couldn’t get XAnalogTV to fill my screen:
 In the source code, the virtual &#34;display&#34; is forced to be within 15% of a standard 4:3 display. Any screen which is outside of this 15% range is just clipped, as shown in this image.</description>
    </item>
    
  </channel>
</rss>